(()=>{"use strict";var __webpack_modules__={924:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"permutation\": () => (/* binding */ permutation),\n/* harmony export */   \"combination\": () => (/* binding */ combination),\n/* harmony export */   \"factorial\": () => (/* binding */ factorial),\n/* harmony export */   \"factoradic\": () => (/* binding */ factoradic),\n/* harmony export */   \"combinadic\": () => (/* binding */ combinadic),\n/* harmony export */   \"randomInteger\": () => (/* binding */ randomInteger),\n/* harmony export */   \"Permutation\": () => (/* binding */ Permutation),\n/* harmony export */   \"Combination\": () => (/* binding */ Combination),\n/* harmony export */   \"BaseN\": () => (/* binding */ BaseN),\n/* harmony export */   \"PowerSet\": () => (/* binding */ PowerSet),\n/* harmony export */   \"CartesianProduct\": () => (/* binding */ CartesianProduct)\n/* harmony export */ });\n/**\n * combinatorics.js\n *\n *  Licensed under the MIT license.\n *  http://www.opensource.org/licenses/mit-license.php\n *\n *  @author: Dan Kogai <dankogai+github@gmail.com>\n *\n *  References:\n *  @link: http://www.ruby-doc.org/core-2.0/Array.html#method-i-combination\n *  @link: http://www.ruby-doc.org/core-2.0/Array.html#method-i-permutation\n *  @link: http://en.wikipedia.org/wiki/Factorial_number_system\n */\nconst version = '1.5.3';\nconst _BI = typeof BigInt == 'function' ? BigInt : Number;\n/**\n * crops BigInt\n */\nconst _crop = (n) => n <= Number.MAX_SAFE_INTEGER ? Number(n) : _BI(n);\n/**\n * calculates `P(n, k)`.\n *\n * @link https://en.wikipedia.org/wiki/Permutation\n */\nfunction permutation(n, k) {\n    if (n < 0)\n        throw new RangeError(`negative n is not acceptable`);\n    if (k < 0)\n        throw new RangeError(`negative k is not acceptable`);\n    if (0 == k)\n        return 1;\n    if (n < k)\n        return 0;\n    [n, k] = [_BI(n), _BI(k)];\n    let p = _BI(1);\n    while (k--)\n        p *= n--;\n    return _crop(p);\n}\n/**\n * calculates `C(n, k)`.\n *\n * @link https://en.wikipedia.org/wiki/Combination\n */\nfunction combination(n, k) {\n    if (0 == k)\n        return 1;\n    if (n == k)\n        return 1;\n    if (n < k)\n        return 0;\n    const P = permutation;\n    const c = _BI(P(n, k)) / _BI(P(k, k));\n    return _crop(c);\n}\n/**\n * calculates `n!` === `P(n, n)`.\n *\n * @link https://en.wikipedia.org/wiki/Factorial\n */\nfunction factorial(n) {\n    return permutation(n, n);\n}\n/**\n * returns the factoradic representation of `n`, least significant order.\n *\n * @link https://en.wikipedia.org/wiki/Factorial_number_system\n * @param {number} l the number of digits\n */\nfunction factoradic(n, l = 0) {\n    if (n < 0)\n        return undefined;\n    let [bn, bf] = [_BI(n), _BI(1)];\n    if (!l) {\n        for (l = 1; bf < bn; bf *= _BI(++l))\n            ;\n        if (bn < bf)\n            bf /= _BI(l--);\n    }\n    else {\n        bf = _BI(factorial(l));\n    }\n    let digits = [0];\n    for (; l; bf /= _BI(l--)) {\n        digits[l] = Math.floor(Number(bn / bf));\n        bn %= bf;\n    }\n    return digits;\n}\n/**\n * `combinadic(n, k)` returns a function\n * that takes `m` as an argument and\n * returns the combinadics representation of `m` for `n C k`.\n *\n * @link https://en.wikipedia.org/wiki/Combinatorial_number_system\n */\nfunction combinadic(n, k) {\n    const count = combination(n, k);\n    return (m) => {\n        if (m < 0 || count <= m)\n            return undefined;\n        let digits = [];\n        let [a, b] = [n, k];\n        let x = _BI(count) - _BI(1) - _BI(m);\n        for (let i = 0; i < k; i++) {\n            a--;\n            while (x < combination(a, b))\n                a--;\n            digits.push(n - 1 - a);\n            x -= _BI(combination(a, b));\n            b--;\n        }\n        return digits;\n    };\n}\n/**\n *\n */\nconst _crypto = typeof crypto !== 'undefined' ? crypto : {};\nconst _randomBytes = typeof _crypto['randomBytes'] === 'function'\n    ? (len) => Uint8Array.from(_crypto['randomBytes'](len))\n    : typeof _crypto['getRandomValues'] === 'function'\n        ? (len) => _crypto['getRandomValues'](new Uint8Array(len))\n        : (len) => Uint8Array.from(Array(len), () => Math.random() * 256);\n/**\n * returns random integer `n` where `min` <= `n` < `max`:\n *\n * if the argument is `BigInt` the result is also `BigInt`.\n *\n * @param {anyint} min\n * @param {anyint} max\n */\nfunction randomInteger(min = 0, max = Math.pow(2, 53)) {\n    let ctor = min.constructor;\n    if (arguments.length === 0) {\n        return Math.floor(Math.random() * ctor(max));\n    }\n    if (arguments.length == 1) {\n        [min, max] = [ctor(0), min];\n    }\n    if (typeof min == 'number') { // number\n        [min, max] = [Math.ceil(Number(min)), Math.ceil(Number(max))];\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    const mag = ctor(max) - ctor(min);\n    const len = mag.toString(16).length;\n    const u8s = _randomBytes(len);\n    const rnd = u8s.reduce((a, v) => ((a << ctor(8)) + ctor(v)), ctor(0));\n    return ((ctor(rnd) * mag) >> ctor(len * 8)) + ctor(min);\n}\n;\n/**\n * Base Class of `js-combinatorics`\n */\nclass _CBase {\n    /**\n     * does `new`\n     * @param args\n     */\n    static of(...args) {\n        return new (Function.prototype.bind.apply(this, [null].concat(args)));\n    }\n    /**\n     * Same as `of` but takes a single array `arg`\n     *\n     * cf. https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n     */\n    static from(arg) {\n        return new (Function.prototype.bind.apply(this, [null].concat(arg)));\n    }\n    /**\n     * Common iterator\n     */\n    [Symbol.iterator]() {\n        return function* (it, len) {\n            for (let i = 0; i < len; i++)\n                yield it.nth(i);\n        }(this, this.length);\n    }\n    /**\n     * returns `[...this]`.\n     */\n    toArray() {\n        return [...this];\n    }\n    /**\n     * tells wether you need `BigInt` to access all elements.\n     */\n    get isBig() {\n        return Number.MAX_SAFE_INTEGER < this.length;\n    }\n    /**\n     * tells wether it is safe to work on this instance.\n     *\n     * * always `true` unless your platform does not support `BigInt`.\n     * * if not, `true` iff `.isBig` is `false`.\n     */\n    get isSafe() {\n        return typeof BigInt !== 'undefined' || !this.isBig;\n    }\n    /**\n    * check n for nth\n    */\n    _check(n) {\n        if (n < 0) {\n            if (this.length < -n)\n                return undefined;\n            return _crop(_BI(this.length) + _BI(n));\n        }\n        if (this.length <= n)\n            return undefined;\n        return n;\n    }\n    /**\n     * get the `n`th element of the iterator.\n     * negative `n` goes backwards\n     */\n    nth(n) { return []; }\n    ;\n    /**\n     * pick random element\n     */\n    sample() {\n        return this.nth(randomInteger(this.length));\n    }\n    /**\n     * an infinite steam of random elements\n     */\n    samples() {\n        return function* (it) {\n            while (true)\n                yield it.sample();\n        }(this);\n    }\n}\n/**\n * Permutation\n */\nclass Permutation extends _CBase {\n    constructor(seed, size = 0) {\n        super();\n        this.seed = [...seed];\n        this.size = 0 < size ? size : this.seed.length;\n        this.length = permutation(this.seed.length, this.size);\n        Object.freeze(this);\n    }\n    nth(n) {\n        n = this._check(n);\n        if (n === undefined)\n            return undefined;\n        const offset = this.seed.length - this.size;\n        const skip = factorial(offset);\n        let digits = factoradic(_BI(n) * _BI(skip), this.seed.length);\n        let source = this.seed.slice();\n        let result = [];\n        for (let i = this.seed.length - 1; offset <= i; i--) {\n            result.push(source.splice(digits[i], 1)[0]);\n        }\n        return result;\n    }\n}\n/**\n * Combination\n */\nclass Combination extends _CBase {\n    constructor(seed, size = 0) {\n        super();\n        this.seed = [...seed];\n        this.size = 0 < size ? size : this.seed.length;\n        this.size = size;\n        this.length = combination(this.seed.length, this.size);\n        this.comb = combinadic(this.seed.length, this.size);\n        Object.freeze(this);\n    }\n    /**\n     * returns an iterator which is more efficient\n     * than the default iterator that uses .nth\n     *\n     * @link https://en.wikipedia.org/wiki/Combinatorial_number_system#Applications\n     */\n    bitwiseIterator() {\n        // console.log('overriding _CBase');\n        const ctor = this.length.constructor;\n        const [zero, one, two] = [ctor(0), ctor(1), ctor(2)];\n        const inc = (x) => {\n            const u = x & -x;\n            const v = u + x;\n            return v + (((v ^ x) / u) >> two);\n        };\n        let x = (one << ctor(this.size)) - one; // 0b11...1\n        return function* (it, len) {\n            for (let i = 0; i < len; i++, x = inc(x)) {\n                let result = [];\n                for (let y = x, j = 0; zero < y; y >>= one, j++) {\n                    if (y & one)\n                        result.push(it.seed[j]);\n                }\n                // console.log(`x = ${x}`);\n                yield result;\n            }\n        }(this, this.length);\n    }\n    nth(n) {\n        n = this._check(n);\n        if (n === undefined)\n            return undefined;\n        let result = [];\n        for (let i of this.comb(n)) {\n            result.push(this.seed[i]);\n        }\n        return result;\n    }\n}\n/**\n * Base N\n */\nclass BaseN extends _CBase {\n    constructor(seed, size = 1) {\n        super();\n        this.seed = [...seed];\n        this.size = size;\n        let base = this.seed.length;\n        this.base = base;\n        let length = size < 1 ? 0\n            : Array(size).fill(_BI(base)).reduce((a, v) => a * v);\n        this.length = _crop(length);\n        Object.freeze(this);\n    }\n    nth(n) {\n        n = this._check(n);\n        if (n === undefined)\n            return undefined;\n        let bn = _BI(n);\n        const bb = _BI(this.base);\n        let result = [];\n        for (let i = 0; i < this.size; i++) {\n            let bd = bn % bb;\n            result.push(this.seed[Number(bd)]);\n            bn -= bd;\n            bn /= bb;\n        }\n        return result;\n    }\n}\n/**\n * Power Set\n */\nclass PowerSet extends _CBase {\n    constructor(seed) {\n        super();\n        this.seed = [...seed];\n        const length = _BI(1) << _BI(this.seed.length);\n        this.length = _crop(length);\n        Object.freeze(this);\n    }\n    nth(n) {\n        n = this._check(n);\n        if (n === undefined)\n            return undefined;\n        let bn = _BI(n);\n        let result = [];\n        for (let bi = _BI(0); bn; bn >>= _BI(1), bi++)\n            if (bn & _BI(1))\n                result.push(this.seed[Number(bi)]);\n        return result;\n    }\n}\n/**\n * Cartesian Product\n */\nclass CartesianProduct extends _CBase {\n    constructor(...args) {\n        super();\n        this.seed = args.map(v => [...v]);\n        this.size = this.seed.length;\n        const length = this.seed.reduce((a, v) => a * _BI(v.length), _BI(1));\n        this.length = _crop(length);\n        Object.freeze(this);\n    }\n    nth(n) {\n        n = this._check(n);\n        if (n === undefined)\n            return undefined;\n        let bn = _BI(n);\n        let result = [];\n        for (let i = 0; i < this.size; i++) {\n            const base = this.seed[i].length;\n            const bb = _BI(base);\n            const bd = bn % bb;\n            result.push(this.seed[i][Number(bd)]);\n            bn -= bd;\n            bn /= bb;\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMjQtY2FyZC1nYW1lLXNvbHZlci8uL25vZGVfbW9kdWxlcy9qcy1jb21iaW5hdG9yaWNzL2NvbWJpbmF0b3JpY3MuanM/ZDI3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGNvbWJpbmF0b3JpY3MuanNcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogIEBhdXRob3I6IERhbiBLb2dhaSA8ZGFua29nYWkrZ2l0aHViQGdtYWlsLmNvbT5cbiAqXG4gKiAgUmVmZXJlbmNlczpcbiAqICBAbGluazogaHR0cDovL3d3dy5ydWJ5LWRvYy5vcmcvY29yZS0yLjAvQXJyYXkuaHRtbCNtZXRob2QtaS1jb21iaW5hdGlvblxuICogIEBsaW5rOiBodHRwOi8vd3d3LnJ1YnktZG9jLm9yZy9jb3JlLTIuMC9BcnJheS5odG1sI21ldGhvZC1pLXBlcm11dGF0aW9uXG4gKiAgQGxpbms6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmFjdG9yaWFsX251bWJlcl9zeXN0ZW1cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMS41LjMnO1xuY29uc3QgX0JJID0gdHlwZW9mIEJpZ0ludCA9PSAnZnVuY3Rpb24nID8gQmlnSW50IDogTnVtYmVyO1xuLyoqXG4gKiBjcm9wcyBCaWdJbnRcbiAqL1xuY29uc3QgX2Nyb3AgPSAobikgPT4gbiA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA/IE51bWJlcihuKSA6IF9CSShuKTtcbi8qKlxuICogY2FsY3VsYXRlcyBgUChuLCBrKWAuXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGVybXV0YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcm11dGF0aW9uKG4sIGspIHtcbiAgICBpZiAobiA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBuZWdhdGl2ZSBuIGlzIG5vdCBhY2NlcHRhYmxlYCk7XG4gICAgaWYgKGsgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbmVnYXRpdmUgayBpcyBub3QgYWNjZXB0YWJsZWApO1xuICAgIGlmICgwID09IGspXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChuIDwgaylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgW24sIGtdID0gW19CSShuKSwgX0JJKGspXTtcbiAgICBsZXQgcCA9IF9CSSgxKTtcbiAgICB3aGlsZSAoay0tKVxuICAgICAgICBwICo9IG4tLTtcbiAgICByZXR1cm4gX2Nyb3AocCk7XG59XG4vKipcbiAqIGNhbGN1bGF0ZXMgYEMobiwgaylgLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5hdGlvbihuLCBrKSB7XG4gICAgaWYgKDAgPT0gaylcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG4gPT0gaylcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKG4gPCBrKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBjb25zdCBQID0gcGVybXV0YXRpb247XG4gICAgY29uc3QgYyA9IF9CSShQKG4sIGspKSAvIF9CSShQKGssIGspKTtcbiAgICByZXR1cm4gX2Nyb3AoYyk7XG59XG4vKipcbiAqIGNhbGN1bGF0ZXMgYG4hYCA9PT0gYFAobiwgbilgLlxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZhY3RvcmlhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmFjdG9yaWFsKG4pIHtcbiAgICByZXR1cm4gcGVybXV0YXRpb24obiwgbik7XG59XG4vKipcbiAqIHJldHVybnMgdGhlIGZhY3RvcmFkaWMgcmVwcmVzZW50YXRpb24gb2YgYG5gLCBsZWFzdCBzaWduaWZpY2FudCBvcmRlci5cbiAqXG4gKiBAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GYWN0b3JpYWxfbnVtYmVyX3N5c3RlbVxuICogQHBhcmFtIHtudW1iZXJ9IGwgdGhlIG51bWJlciBvZiBkaWdpdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZhY3RvcmFkaWMobiwgbCA9IDApIHtcbiAgICBpZiAobiA8IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbGV0IFtibiwgYmZdID0gW19CSShuKSwgX0JJKDEpXTtcbiAgICBpZiAoIWwpIHtcbiAgICAgICAgZm9yIChsID0gMTsgYmYgPCBibjsgYmYgKj0gX0JJKCsrbCkpXG4gICAgICAgICAgICA7XG4gICAgICAgIGlmIChibiA8IGJmKVxuICAgICAgICAgICAgYmYgLz0gX0JJKGwtLSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiZiA9IF9CSShmYWN0b3JpYWwobCkpO1xuICAgIH1cbiAgICBsZXQgZGlnaXRzID0gWzBdO1xuICAgIGZvciAoOyBsOyBiZiAvPSBfQkkobC0tKSkge1xuICAgICAgICBkaWdpdHNbbF0gPSBNYXRoLmZsb29yKE51bWJlcihibiAvIGJmKSk7XG4gICAgICAgIGJuICU9IGJmO1xuICAgIH1cbiAgICByZXR1cm4gZGlnaXRzO1xufVxuLyoqXG4gKiBgY29tYmluYWRpYyhuLCBrKWAgcmV0dXJucyBhIGZ1bmN0aW9uXG4gKiB0aGF0IHRha2VzIGBtYCBhcyBhbiBhcmd1bWVudCBhbmRcbiAqIHJldHVybnMgdGhlIGNvbWJpbmFkaWNzIHJlcHJlc2VudGF0aW9uIG9mIGBtYCBmb3IgYG4gQyBrYC5cbiAqXG4gKiBAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5hdG9yaWFsX251bWJlcl9zeXN0ZW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmFkaWMobiwgaykge1xuICAgIGNvbnN0IGNvdW50ID0gY29tYmluYXRpb24obiwgayk7XG4gICAgcmV0dXJuIChtKSA9PiB7XG4gICAgICAgIGlmIChtIDwgMCB8fCBjb3VudCA8PSBtKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGRpZ2l0cyA9IFtdO1xuICAgICAgICBsZXQgW2EsIGJdID0gW24sIGtdO1xuICAgICAgICBsZXQgeCA9IF9CSShjb3VudCkgLSBfQkkoMSkgLSBfQkkobSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgICAgICBhLS07XG4gICAgICAgICAgICB3aGlsZSAoeCA8IGNvbWJpbmF0aW9uKGEsIGIpKVxuICAgICAgICAgICAgICAgIGEtLTtcbiAgICAgICAgICAgIGRpZ2l0cy5wdXNoKG4gLSAxIC0gYSk7XG4gICAgICAgICAgICB4IC09IF9CSShjb21iaW5hdGlvbihhLCBiKSk7XG4gICAgICAgICAgICBiLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2l0cztcbiAgICB9O1xufVxuLyoqXG4gKlxuICovXG5jb25zdCBfY3J5cHRvID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgPyBjcnlwdG8gOiB7fTtcbmNvbnN0IF9yYW5kb21CeXRlcyA9IHR5cGVvZiBfY3J5cHRvWydyYW5kb21CeXRlcyddID09PSAnZnVuY3Rpb24nXG4gICAgPyAobGVuKSA9PiBVaW50OEFycmF5LmZyb20oX2NyeXB0b1sncmFuZG9tQnl0ZXMnXShsZW4pKVxuICAgIDogdHlwZW9mIF9jcnlwdG9bJ2dldFJhbmRvbVZhbHVlcyddID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKGxlbikgPT4gX2NyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10obmV3IFVpbnQ4QXJyYXkobGVuKSlcbiAgICAgICAgOiAobGVuKSA9PiBVaW50OEFycmF5LmZyb20oQXJyYXkobGVuKSwgKCkgPT4gTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4vKipcbiAqIHJldHVybnMgcmFuZG9tIGludGVnZXIgYG5gIHdoZXJlIGBtaW5gIDw9IGBuYCA8IGBtYXhgOlxuICpcbiAqIGlmIHRoZSBhcmd1bWVudCBpcyBgQmlnSW50YCB0aGUgcmVzdWx0IGlzIGFsc28gYEJpZ0ludGAuXG4gKlxuICogQHBhcmFtIHthbnlpbnR9IG1pblxuICogQHBhcmFtIHthbnlpbnR9IG1heFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSW50ZWdlcihtaW4gPSAwLCBtYXggPSBNYXRoLnBvdygyLCA1MykpIHtcbiAgICBsZXQgY3RvciA9IG1pbi5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY3RvcihtYXgpKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBbbWluLCBtYXhdID0gW2N0b3IoMCksIG1pbl07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWluID09ICdudW1iZXInKSB7IC8vIG51bWJlclxuICAgICAgICBbbWluLCBtYXhdID0gW01hdGguY2VpbChOdW1iZXIobWluKSksIE1hdGguY2VpbChOdW1iZXIobWF4KSldO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xuICAgIH1cbiAgICBjb25zdCBtYWcgPSBjdG9yKG1heCkgLSBjdG9yKG1pbik7XG4gICAgY29uc3QgbGVuID0gbWFnLnRvU3RyaW5nKDE2KS5sZW5ndGg7XG4gICAgY29uc3QgdThzID0gX3JhbmRvbUJ5dGVzKGxlbik7XG4gICAgY29uc3Qgcm5kID0gdThzLnJlZHVjZSgoYSwgdikgPT4gKChhIDw8IGN0b3IoOCkpICsgY3Rvcih2KSksIGN0b3IoMCkpO1xuICAgIHJldHVybiAoKGN0b3Iocm5kKSAqIG1hZykgPj4gY3RvcihsZW4gKiA4KSkgKyBjdG9yKG1pbik7XG59XG47XG4vKipcbiAqIEJhc2UgQ2xhc3Mgb2YgYGpzLWNvbWJpbmF0b3JpY3NgXG4gKi9cbmNsYXNzIF9DQmFzZSB7XG4gICAgLyoqXG4gICAgICogZG9lcyBgbmV3YFxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICovXG4gICAgc3RhdGljIG9mKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkodGhpcywgW251bGxdLmNvbmNhdChhcmdzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBvZmAgYnV0IHRha2VzIGEgc2luZ2xlIGFycmF5IGBhcmdgXG4gICAgICpcbiAgICAgKiBjZi4gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTYwNjc5Ny91c2Utb2YtYXBwbHktd2l0aC1uZXctb3BlcmF0b3ItaXMtdGhpcy1wb3NzaWJsZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKGFyZykge1xuICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseSh0aGlzLCBbbnVsbF0uY29uY2F0KGFyZykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tbW9uIGl0ZXJhdG9yXG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiogKGl0LCBsZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgeWllbGQgaXQubnRoKGkpO1xuICAgICAgICB9KHRoaXMsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBgWy4uLnRoaXNdYC5cbiAgICAgKi9cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0ZWxscyB3ZXRoZXIgeW91IG5lZWQgYEJpZ0ludGAgdG8gYWNjZXNzIGFsbCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBnZXQgaXNCaWcoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA8IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0ZWxscyB3ZXRoZXIgaXQgaXMgc2FmZSB0byB3b3JrIG9uIHRoaXMgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiAqIGFsd2F5cyBgdHJ1ZWAgdW5sZXNzIHlvdXIgcGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBgQmlnSW50YC5cbiAgICAgKiAqIGlmIG5vdCwgYHRydWVgIGlmZiBgLmlzQmlnYCBpcyBgZmFsc2VgLlxuICAgICAqL1xuICAgIGdldCBpc1NhZmUoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJyB8fCAhdGhpcy5pc0JpZztcbiAgICB9XG4gICAgLyoqXG4gICAgKiBjaGVjayBuIGZvciBudGhcbiAgICAqL1xuICAgIF9jaGVjayhuKSB7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgLW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiBfY3JvcChfQkkodGhpcy5sZW5ndGgpICsgX0JJKG4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPD0gbilcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGBuYHRoIGVsZW1lbnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAqIG5lZ2F0aXZlIGBuYCBnb2VzIGJhY2t3YXJkc1xuICAgICAqL1xuICAgIG50aChuKSB7IHJldHVybiBbXTsgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBwaWNrIHJhbmRvbSBlbGVtZW50XG4gICAgICovXG4gICAgc2FtcGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udGgocmFuZG9tSW50ZWdlcih0aGlzLmxlbmd0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhbiBpbmZpbml0ZSBzdGVhbSBvZiByYW5kb20gZWxlbWVudHNcbiAgICAgKi9cbiAgICBzYW1wbGVzKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24qIChpdCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpXG4gICAgICAgICAgICAgICAgeWllbGQgaXQuc2FtcGxlKCk7XG4gICAgICAgIH0odGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiBQZXJtdXRhdGlvblxuICovXG5leHBvcnQgY2xhc3MgUGVybXV0YXRpb24gZXh0ZW5kcyBfQ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQsIHNpemUgPSAwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VlZCA9IFsuLi5zZWVkXTtcbiAgICAgICAgdGhpcy5zaXplID0gMCA8IHNpemUgPyBzaXplIDogdGhpcy5zZWVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBwZXJtdXRhdGlvbih0aGlzLnNlZWQubGVuZ3RoLCB0aGlzLnNpemUpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBudGgobikge1xuICAgICAgICBuID0gdGhpcy5fY2hlY2sobik7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLnNlZWQubGVuZ3RoIC0gdGhpcy5zaXplO1xuICAgICAgICBjb25zdCBza2lwID0gZmFjdG9yaWFsKG9mZnNldCk7XG4gICAgICAgIGxldCBkaWdpdHMgPSBmYWN0b3JhZGljKF9CSShuKSAqIF9CSShza2lwKSwgdGhpcy5zZWVkLmxlbmd0aCk7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnNlZWQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zZWVkLmxlbmd0aCAtIDE7IG9mZnNldCA8PSBpOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNvdXJjZS5zcGxpY2UoZGlnaXRzW2ldLCAxKVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbiAqIENvbWJpbmF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb21iaW5hdGlvbiBleHRlbmRzIF9DQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VlZCwgc2l6ZSA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWVkID0gWy4uLnNlZWRdO1xuICAgICAgICB0aGlzLnNpemUgPSAwIDwgc2l6ZSA/IHNpemUgOiB0aGlzLnNlZWQubGVuZ3RoO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGNvbWJpbmF0aW9uKHRoaXMuc2VlZC5sZW5ndGgsIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMuY29tYiA9IGNvbWJpbmFkaWModGhpcy5zZWVkLmxlbmd0aCwgdGhpcy5zaXplKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCBpcyBtb3JlIGVmZmljaWVudFxuICAgICAqIHRoYW4gdGhlIGRlZmF1bHQgaXRlcmF0b3IgdGhhdCB1c2VzIC5udGhcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmF0b3JpYWxfbnVtYmVyX3N5c3RlbSNBcHBsaWNhdGlvbnNcbiAgICAgKi9cbiAgICBiaXR3aXNlSXRlcmF0b3IoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvdmVycmlkaW5nIF9DQmFzZScpO1xuICAgICAgICBjb25zdCBjdG9yID0gdGhpcy5sZW5ndGguY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IFt6ZXJvLCBvbmUsIHR3b10gPSBbY3RvcigwKSwgY3RvcigxKSwgY3RvcigyKV07XG4gICAgICAgIGNvbnN0IGluYyA9ICh4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1ID0geCAmIC14O1xuICAgICAgICAgICAgY29uc3QgdiA9IHUgKyB4O1xuICAgICAgICAgICAgcmV0dXJuIHYgKyAoKCh2IF4geCkgLyB1KSA+PiB0d28pO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeCA9IChvbmUgPDwgY3Rvcih0aGlzLnNpemUpKSAtIG9uZTsgLy8gMGIxMS4uLjFcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoaXQsIGxlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKywgeCA9IGluYyh4KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0geCwgaiA9IDA7IHplcm8gPCB5OyB5ID4+PSBvbmUsIGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSAmIG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0LnNlZWRbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgeCA9ICR7eH1gKTtcbiAgICAgICAgICAgICAgICB5aWVsZCByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0odGhpcywgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBudGgobikge1xuICAgICAgICBuID0gdGhpcy5fY2hlY2sobik7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgb2YgdGhpcy5jb21iKG4pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlZWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIE5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VOIGV4dGVuZHMgX0NCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihzZWVkLCBzaXplID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlZWQgPSBbLi4uc2VlZF07XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIGxldCBiYXNlID0gdGhpcy5zZWVkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHNpemUgPCAxID8gMFxuICAgICAgICAgICAgOiBBcnJheShzaXplKS5maWxsKF9CSShiYXNlKSkucmVkdWNlKChhLCB2KSA9PiBhICogdik7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gX2Nyb3AobGVuZ3RoKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgbnRoKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuX2NoZWNrKG4pO1xuICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGJuID0gX0JJKG4pO1xuICAgICAgICBjb25zdCBiYiA9IF9CSSh0aGlzLmJhc2UpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiZCA9IGJuICUgYmI7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlZWRbTnVtYmVyKGJkKV0pO1xuICAgICAgICAgICAgYm4gLT0gYmQ7XG4gICAgICAgICAgICBibiAvPSBiYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogUG93ZXIgU2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBQb3dlclNldCBleHRlbmRzIF9DQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlZWQgPSBbLi4uc2VlZF07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IF9CSSgxKSA8PCBfQkkodGhpcy5zZWVkLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gX2Nyb3AobGVuZ3RoKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgbnRoKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuX2NoZWNrKG4pO1xuICAgICAgICBpZiAobiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGJuID0gX0JJKG4pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGJpID0gX0JJKDApOyBibjsgYm4gPj49IF9CSSgxKSwgYmkrKylcbiAgICAgICAgICAgIGlmIChibiAmIF9CSSgxKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnNlZWRbTnVtYmVyKGJpKV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogQ2FydGVzaWFuIFByb2R1Y3RcbiAqL1xuZXhwb3J0IGNsYXNzIENhcnRlc2lhblByb2R1Y3QgZXh0ZW5kcyBfQ0Jhc2Uge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWVkID0gYXJncy5tYXAodiA9PiBbLi4udl0pO1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLnNlZWQubGVuZ3RoO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnNlZWQucmVkdWNlKChhLCB2KSA9PiBhICogX0JJKHYubGVuZ3RoKSwgX0JJKDEpKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBfY3JvcChsZW5ndGgpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBudGgobikge1xuICAgICAgICBuID0gdGhpcy5fY2hlY2sobik7XG4gICAgICAgIGlmIChuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYm4gPSBfQkkobik7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuc2VlZFtpXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBiYiA9IF9CSShiYXNlKTtcbiAgICAgICAgICAgIGNvbnN0IGJkID0gYm4gJSBiYjtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VlZFtpXVtOdW1iZXIoYmQpXSk7XG4gICAgICAgICAgICBibiAtPSBiZDtcbiAgICAgICAgICAgIGJuIC89IGJiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///924\n")},607:(__unused_webpack_module,exports,__webpack_require__)=>{eval('var __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\nconst solver_1 = __webpack_require__(168);\ndocument.getElementById("card1").value = Math.floor(1 + Math.random() * 13).toString();\ndocument.getElementById("card2").value = Math.floor(1 + Math.random() * 13).toString();\ndocument.getElementById("card3").value = Math.floor(1 + Math.random() * 13).toString();\ndocument.getElementById("card4").value = Math.floor(1 + Math.random() * 13).toString();\nfor (const elem of document.getElementsByClassName("card-picker")) {\n    updateImage(elem);\n    elem.addEventListener("change", event => updateImage(event.target));\n}\ndocument.getElementById("solve").addEventListener("click", solve);\nfunction solve() {\n    const cards = [];\n    for (let i = 1; i <= 4; i++) {\n        const value = Number(document.getElementById(`card${i}`).value);\n        if (value >= 1 && value <= 13) {\n            cards.push(value);\n        }\n        else {\n            alert(`Card ${i} is invalid`);\n            return;\n        }\n    }\n    const solutionsDiv = document.getElementById("solutions");\n    while (solutionsDiv.lastElementChild) {\n        solutionsDiv.removeChild(solutionsDiv.lastElementChild);\n    }\n    const solutions = solver_1.Solver.solve(cards);\n    if (solutions.length !== 0) {\n        const solutionElements = solver_1.Solver.print(solutions).map(output => {\n            const solutionElement = document.createElement("pre");\n            solutionElement.classList.add("text-center", "col-12", "col-sm-4", "col-md-3", "col-lg-2");\n            solutionElement.innerText = output;\n            return solutionElement;\n        });\n        solutionsDiv.append(...solutionElements);\n    }\n    else {\n        const noSolutionsElement = document.createElement("pre");\n        noSolutionsElement.innerText = "No solutions";\n        solutionsDiv.appendChild(noSolutionsElement);\n    }\n}\nfunction updateImage(elem) {\n    var _a, _b;\n    const imageElem = (_b = (_a = elem.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.getElementsByClassName("card-image")[0].getElementsByTagName("img")[0];\n    const face = ["Clubs", "Diamonds", "Hearts", "Spades"][Math.floor(Math.random() * 4)];\n    imageElem.src = `images/light/${elem.value}${face[0]}.svg`;\n    imageElem.alt = `${elem.value} of ${face}`;\n    imageElem.title = `${elem.value} of ${face}`;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA3LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDZCQUE2QyxFQUFFLGFBQWEsQ0FBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxHQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1Qiw0REFBNEQsRUFBRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixHQUFHO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVcsRUFBRSxRQUFRO0FBQ3pELHVCQUF1QixZQUFZLEtBQUssS0FBSztBQUM3Qyx5QkFBeUIsWUFBWSxLQUFLLEtBQUs7QUFDL0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yNC1jYXJkLWdhbWUtc29sdmVyLy4vc3JjL2luZGV4LnRzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3NvbHZlclwiKTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FyZDFcIikudmFsdWUgPSBNYXRoLmZsb29yKDEgKyBNYXRoLnJhbmRvbSgpICogMTMpLnRvU3RyaW5nKCk7XG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhcmQyXCIpLnZhbHVlID0gTWF0aC5mbG9vcigxICsgTWF0aC5yYW5kb20oKSAqIDEzKS50b1N0cmluZygpO1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYXJkM1wiKS52YWx1ZSA9IE1hdGguZmxvb3IoMSArIE1hdGgucmFuZG9tKCkgKiAxMykudG9TdHJpbmcoKTtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FyZDRcIikudmFsdWUgPSBNYXRoLmZsb29yKDEgKyBNYXRoLnJhbmRvbSgpICogMTMpLnRvU3RyaW5nKCk7XG5mb3IgKGNvbnN0IGVsZW0gb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNhcmQtcGlja2VyXCIpKSB7XG4gICAgdXBkYXRlSW1hZ2UoZWxlbSk7XG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHVwZGF0ZUltYWdlKGV2ZW50LnRhcmdldCkpO1xufVxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb2x2ZVwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgc29sdmUpO1xuZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgY29uc3QgY2FyZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA0OyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBOdW1iZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGNhcmQke2l9YCkudmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPj0gMSAmJiB2YWx1ZSA8PSAxMykge1xuICAgICAgICAgICAgY2FyZHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGVydChgQ2FyZCAke2l9IGlzIGludmFsaWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzb2x1dGlvbnNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvbHV0aW9uc1wiKTtcbiAgICB3aGlsZSAoc29sdXRpb25zRGl2Lmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgc29sdXRpb25zRGl2LnJlbW92ZUNoaWxkKHNvbHV0aW9uc0Rpdi5sYXN0RWxlbWVudENoaWxkKTtcbiAgICB9XG4gICAgY29uc3Qgc29sdXRpb25zID0gc29sdmVyXzEuU29sdmVyLnNvbHZlKGNhcmRzKTtcbiAgICBpZiAoc29sdXRpb25zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBzb2x1dGlvbkVsZW1lbnRzID0gc29sdmVyXzEuU29sdmVyLnByaW50KHNvbHV0aW9ucykubWFwKG91dHB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzb2x1dGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicHJlXCIpO1xuICAgICAgICAgICAgc29sdXRpb25FbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ0ZXh0LWNlbnRlclwiLCBcImNvbC0xMlwiLCBcImNvbC1zbS00XCIsIFwiY29sLW1kLTNcIiwgXCJjb2wtbGctMlwiKTtcbiAgICAgICAgICAgIHNvbHV0aW9uRWxlbWVudC5pbm5lclRleHQgPSBvdXRwdXQ7XG4gICAgICAgICAgICByZXR1cm4gc29sdXRpb25FbGVtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgc29sdXRpb25zRGl2LmFwcGVuZCguLi5zb2x1dGlvbkVsZW1lbnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vU29sdXRpb25zRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIik7XG4gICAgICAgIG5vU29sdXRpb25zRWxlbWVudC5pbm5lclRleHQgPSBcIk5vIHNvbHV0aW9uc1wiO1xuICAgICAgICBzb2x1dGlvbnNEaXYuYXBwZW5kQ2hpbGQobm9Tb2x1dGlvbnNFbGVtZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVJbWFnZShlbGVtKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBpbWFnZUVsZW0gPSAoX2IgPSAoX2EgPSBlbGVtLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNhcmQtaW1hZ2VcIilbMF0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbWdcIilbMF07XG4gICAgY29uc3QgZmFjZSA9IFtcIkNsdWJzXCIsIFwiRGlhbW9uZHNcIiwgXCJIZWFydHNcIiwgXCJTcGFkZXNcIl1bTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCldO1xuICAgIGltYWdlRWxlbS5zcmMgPSBgaW1hZ2VzL2xpZ2h0LyR7ZWxlbS52YWx1ZX0ke2ZhY2VbMF19LnN2Z2A7XG4gICAgaW1hZ2VFbGVtLmFsdCA9IGAke2VsZW0udmFsdWV9IG9mICR7ZmFjZX1gO1xuICAgIGltYWdlRWxlbS50aXRsZSA9IGAke2VsZW0udmFsdWV9IG9mICR7ZmFjZX1gO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///607\n')},968:(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Log = exports.Exponent = exports.Divide = exports.Multiply = exports.Subtract = exports.Add = void 0;\nexports.Add = {\n    operate(a, b) {\n        return a + b;\n    },\n    toString(a, b) {\n        return `${a} + ${b}`;\n    }\n};\nexports.Subtract = {\n    operate(a, b) {\n        return a - b;\n    },\n    toString(a, b) {\n        return `${a} - ${b}`;\n    }\n};\nexports.Multiply = {\n    operate(a, b) {\n        return a * b;\n    },\n    toString(a, b) {\n        return `${a} * ${b}`;\n    }\n};\nexports.Divide = {\n    operate(a, b) {\n        return a / b;\n    },\n    toString(a, b) {\n        return `${a} / ${b}`;\n    }\n};\nexports.Exponent = {\n    operate(a, b) {\n        return Math.pow(a, b);\n    },\n    toString(a, b) {\n        return `${a} ^ ${b}`;\n    }\n};\nexports.Log = {\n    operate(a, b) {\n        return Math.log(b) / Math.log(a);\n    },\n    toString(a, b) {\n        return `log_${a}(${b})`;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVztBQUNuRyxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixHQUFHLElBQUksRUFBRTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsR0FBRyxJQUFJLEVBQUU7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLEdBQUcsSUFBSSxFQUFFO0FBQzNCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixHQUFHLElBQUksRUFBRTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsR0FBRyxJQUFJLEVBQUU7QUFDM0I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLEVBQUUsR0FBRyxFQUFFO0FBQzdCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8yNC1jYXJkLWdhbWUtc29sdmVyLy4vc3JjL29wZXJhdGlvbi50cz85ODYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2cgPSBleHBvcnRzLkV4cG9uZW50ID0gZXhwb3J0cy5EaXZpZGUgPSBleHBvcnRzLk11bHRpcGx5ID0gZXhwb3J0cy5TdWJ0cmFjdCA9IGV4cG9ydHMuQWRkID0gdm9pZCAwO1xuZXhwb3J0cy5BZGQgPSB7XG4gICAgb3BlcmF0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICsgYjtcbiAgICB9LFxuICAgIHRvU3RyaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGAke2F9ICsgJHtifWA7XG4gICAgfVxufTtcbmV4cG9ydHMuU3VidHJhY3QgPSB7XG4gICAgb3BlcmF0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICB9LFxuICAgIHRvU3RyaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGAke2F9IC0gJHtifWA7XG4gICAgfVxufTtcbmV4cG9ydHMuTXVsdGlwbHkgPSB7XG4gICAgb3BlcmF0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBhICogYjtcbiAgICB9LFxuICAgIHRvU3RyaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGAke2F9ICogJHtifWA7XG4gICAgfVxufTtcbmV4cG9ydHMuRGl2aWRlID0ge1xuICAgIG9wZXJhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgfSxcbiAgICB0b1N0cmluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBgJHthfSAvICR7Yn1gO1xuICAgIH1cbn07XG5leHBvcnRzLkV4cG9uZW50ID0ge1xuICAgIG9wZXJhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coYSwgYik7XG4gICAgfSxcbiAgICB0b1N0cmluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBgJHthfSBeICR7Yn1gO1xuICAgIH1cbn07XG5leHBvcnRzLkxvZyA9IHtcbiAgICBvcGVyYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKGIpIC8gTWF0aC5sb2coYSk7XG4gICAgfSxcbiAgICB0b1N0cmluZyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBgbG9nXyR7YX0oJHtifSlgO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///968\n')},168:function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Solver = void 0;\nconst js_combinatorics_1 = __webpack_require__(924);\nconst operations = __importStar(__webpack_require__(968));\nclass Solver {\n    static solve(hand) {\n        const solutions = [];\n        const hands = [];\n        for (let i = 0; i < Math.pow(2, hand.filter(card => card > 10).length); i++) {\n            const newHand = [];\n            let face = 1;\n            for (const card of hand) {\n                if (card > 10) {\n                    if ((i / face) % 2 === 0) {\n                        newHand.push(card);\n                    }\n                    else {\n                        newHand.push(10);\n                    }\n                    face *= 2;\n                }\n                else {\n                    newHand.push(card);\n                }\n            }\n            hands.push(newHand);\n        }\n        for (const hand of hands) {\n            for (const solution of new js_combinatorics_1.Permutation(hand)) {\n                for (const operations of new js_combinatorics_1.BaseN(Solver.ops, 3)) {\n                    // (a b) (c d)\n                    let left = operations[0].operate(solution[0], solution[1]);\n                    let right = operations[1].operate(solution[2], solution[3]);\n                    let answer = operations[2].operate(left, right);\n                    if (answer === 24) {\n                        solutions.push({\n                            operations,\n                            parentheses: 0,\n                            solution,\n                        });\n                    }\n                    // ((a b) c) d\n                    left = operations[0].operate(solution[0], solution[1]);\n                    right = operations[1].operate(left, solution[2]);\n                    answer = operations[2].operate(right, solution[3]);\n                    if (answer === 24) {\n                        solutions.push({\n                            operations,\n                            parentheses: 1,\n                            solution,\n                        });\n                    }\n                    // (a (b c)) d\n                    left = operations[0].operate(solution[1], solution[2]);\n                    right = operations[1].operate(solution[0], left);\n                    answer = operations[2].operate(right, solution[3]);\n                    if (answer === 24) {\n                        solutions.push({\n                            operations,\n                            parentheses: 2,\n                            solution,\n                        });\n                    }\n                    // a ((b c) d)\n                    left = operations[0].operate(solution[1], solution[2]);\n                    right = operations[1].operate(left, solution[3]);\n                    answer = operations[2].operate(solution[0], right);\n                    if (answer == 24) {\n                        solutions.push({\n                            operations,\n                            parentheses: 3,\n                            solution,\n                        });\n                    }\n                    // a (b (c d))\n                    left = operations[0].operate(solution[2], solution[3]);\n                    right = operations[1].operate(solution[1], left);\n                    answer = operations[2].operate(solution[0], right);\n                    if (answer === 24) {\n                        solutions.push({\n                            operations,\n                            parentheses: 4,\n                            solution,\n                        });\n                    }\n                }\n            }\n        }\n        return solutions;\n    }\n    static print(solutions) {\n        const outputs = [];\n        for (const { operations, parentheses, solution } of solutions) {\n            if (parentheses === 0) {\n                // (a b) (c d)\n                const left = `(${operations[0].toString(solution[0], solution[1])})`;\n                const right = `(${operations[1].toString(solution[2], solution[3])})`;\n                outputs.push(operations[2].toString(left, right));\n            }\n            else if (parentheses === 1) {\n                // ((a b) c) d\n                const left = `(${operations[0].toString(solution[0], solution[1])})`;\n                const right = `(${operations[1].toString(left, solution[2])})`;\n                outputs.push(operations[2].toString(right, solution[3]));\n            }\n            else if (parentheses === 2) {\n                // (a (b c)) d\n                const left = `(${operations[0].toString(solution[1], solution[2])})`;\n                const right = `(${operations[1].toString(solution[0], left)})`;\n                outputs.push(operations[2].toString(right, solution[3]));\n            }\n            else if (parentheses === 3) {\n                // a ((b c) d)\n                const left = `(${operations[0].toString(solution[1], solution[2])})`;\n                const right = `(${operations[1].toString(left, solution[3])})`;\n                outputs.push(operations[2].toString(solution[0], right));\n            }\n            else if (parentheses === 4) {\n                // a (b (c d))\n                const left = `(${operations[0].toString(solution[2], solution[3])})`;\n                const right = `(${operations[1].toString(solution[1], left)})`;\n                outputs.push(operations[2].toString(solution[0], right));\n            }\n        }\n        return outputs;\n    }\n}\nexports.Solver = Solver;\nSolver.ops = [\n    operations.Add, operations.Subtract, operations.Multiply,\n    operations.Divide, operations.Exponent, operations.Log\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLDJCQUEyQixtQkFBTyxDQUFDLEdBQWtCO0FBQ3JELGdDQUFnQyxtQkFBTyxDQUFDLEdBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQXdEO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9DQUFvQztBQUN6RDtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRDtBQUNsRixrQ0FBa0MsaURBQWlEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRDtBQUNsRixrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRDtBQUNsRixrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRDtBQUNsRixrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRDtBQUNsRixrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLzI0LWNhcmQtZ2FtZS1zb2x2ZXIvLi9zcmMvc29sdmVyLnRzP2MxNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29sdmVyID0gdm9pZCAwO1xuY29uc3QganNfY29tYmluYXRvcmljc18xID0gcmVxdWlyZShcImpzLWNvbWJpbmF0b3JpY3NcIik7XG5jb25zdCBvcGVyYXRpb25zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKSk7XG5jbGFzcyBTb2x2ZXIge1xuICAgIHN0YXRpYyBzb2x2ZShoYW5kKSB7XG4gICAgICAgIGNvbnN0IHNvbHV0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBoYW5kcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgucG93KDIsIGhhbmQuZmlsdGVyKGNhcmQgPT4gY2FyZCA+IDEwKS5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hhbmQgPSBbXTtcbiAgICAgICAgICAgIGxldCBmYWNlID0gMTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FyZCBvZiBoYW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhcmQgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGkgLyBmYWNlKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hhbmQucHVzaChjYXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hhbmQucHVzaCgxMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmFjZSAqPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGFuZC5wdXNoKGNhcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRzLnB1c2gobmV3SGFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBoYW5kIG9mIGhhbmRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvbHV0aW9uIG9mIG5ldyBqc19jb21iaW5hdG9yaWNzXzEuUGVybXV0YXRpb24oaGFuZCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbnMgb2YgbmV3IGpzX2NvbWJpbmF0b3JpY3NfMS5CYXNlTihTb2x2ZXIub3BzLCAzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAoYSBiKSAoYyBkKVxuICAgICAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IG9wZXJhdGlvbnNbMF0ub3BlcmF0ZShzb2x1dGlvblswXSwgc29sdXRpb25bMV0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSBvcGVyYXRpb25zWzFdLm9wZXJhdGUoc29sdXRpb25bMl0sIHNvbHV0aW9uWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFuc3dlciA9IG9wZXJhdGlvbnNbMl0ub3BlcmF0ZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnN3ZXIgPT09IDI0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNlczogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vICgoYSBiKSBjKSBkXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBvcGVyYXRpb25zWzBdLm9wZXJhdGUoc29sdXRpb25bMF0sIHNvbHV0aW9uWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSBvcGVyYXRpb25zWzFdLm9wZXJhdGUobGVmdCwgc29sdXRpb25bMl0pO1xuICAgICAgICAgICAgICAgICAgICBhbnN3ZXIgPSBvcGVyYXRpb25zWzJdLm9wZXJhdGUocmlnaHQsIHNvbHV0aW9uWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuc3dlciA9PT0gMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2VzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gKGEgKGIgYykpIGRcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG9wZXJhdGlvbnNbMF0ub3BlcmF0ZShzb2x1dGlvblsxXSwgc29sdXRpb25bMl0pO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IG9wZXJhdGlvbnNbMV0ub3BlcmF0ZShzb2x1dGlvblswXSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlciA9IG9wZXJhdGlvbnNbMl0ub3BlcmF0ZShyaWdodCwgc29sdXRpb25bM10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5zd2VyID09PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzZXM6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhICgoYiBjKSBkKVxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gb3BlcmF0aW9uc1swXS5vcGVyYXRlKHNvbHV0aW9uWzFdLCBzb2x1dGlvblsyXSk7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gb3BlcmF0aW9uc1sxXS5vcGVyYXRlKGxlZnQsIHNvbHV0aW9uWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgYW5zd2VyID0gb3BlcmF0aW9uc1syXS5vcGVyYXRlKHNvbHV0aW9uWzBdLCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnN3ZXIgPT0gMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2VzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYSAoYiAoYyBkKSlcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG9wZXJhdGlvbnNbMF0ub3BlcmF0ZShzb2x1dGlvblsyXSwgc29sdXRpb25bM10pO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IG9wZXJhdGlvbnNbMV0ub3BlcmF0ZShzb2x1dGlvblsxXSwgbGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIGFuc3dlciA9IG9wZXJhdGlvbnNbMl0ub3BlcmF0ZShzb2x1dGlvblswXSwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5zd2VyID09PSAyNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzZXM6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29sdXRpb25zO1xuICAgIH1cbiAgICBzdGF0aWMgcHJpbnQoc29sdXRpb25zKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IG9wZXJhdGlvbnMsIHBhcmVudGhlc2VzLCBzb2x1dGlvbiB9IG9mIHNvbHV0aW9ucykge1xuICAgICAgICAgICAgaWYgKHBhcmVudGhlc2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gKGEgYikgKGMgZClcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gYCgke29wZXJhdGlvbnNbMF0udG9TdHJpbmcoc29sdXRpb25bMF0sIHNvbHV0aW9uWzFdKX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGAoJHtvcGVyYXRpb25zWzFdLnRvU3RyaW5nKHNvbHV0aW9uWzJdLCBzb2x1dGlvblszXSl9KWA7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG9wZXJhdGlvbnNbMl0udG9TdHJpbmcobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudGhlc2VzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gKChhIGIpIGMpIGRcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gYCgke29wZXJhdGlvbnNbMF0udG9TdHJpbmcoc29sdXRpb25bMF0sIHNvbHV0aW9uWzFdKX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGAoJHtvcGVyYXRpb25zWzFdLnRvU3RyaW5nKGxlZnQsIHNvbHV0aW9uWzJdKX0pYDtcbiAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gob3BlcmF0aW9uc1syXS50b1N0cmluZyhyaWdodCwgc29sdXRpb25bM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudGhlc2VzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gKGEgKGIgYykpIGRcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gYCgke29wZXJhdGlvbnNbMF0udG9TdHJpbmcoc29sdXRpb25bMV0sIHNvbHV0aW9uWzJdKX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGAoJHtvcGVyYXRpb25zWzFdLnRvU3RyaW5nKHNvbHV0aW9uWzBdLCBsZWZ0KX0pYDtcbiAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gob3BlcmF0aW9uc1syXS50b1N0cmluZyhyaWdodCwgc29sdXRpb25bM10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudGhlc2VzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgLy8gYSAoKGIgYykgZClcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gYCgke29wZXJhdGlvbnNbMF0udG9TdHJpbmcoc29sdXRpb25bMV0sIHNvbHV0aW9uWzJdKX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGAoJHtvcGVyYXRpb25zWzFdLnRvU3RyaW5nKGxlZnQsIHNvbHV0aW9uWzNdKX0pYDtcbiAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gob3BlcmF0aW9uc1syXS50b1N0cmluZyhzb2x1dGlvblswXSwgcmlnaHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudGhlc2VzID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gYSAoYiAoYyBkKSlcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gYCgke29wZXJhdGlvbnNbMF0udG9TdHJpbmcoc29sdXRpb25bMl0sIHNvbHV0aW9uWzNdKX0pYDtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGAoJHtvcGVyYXRpb25zWzFdLnRvU3RyaW5nKHNvbHV0aW9uWzFdLCBsZWZ0KX0pYDtcbiAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gob3BlcmF0aW9uc1syXS50b1N0cmluZyhzb2x1dGlvblswXSwgcmlnaHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG59XG5leHBvcnRzLlNvbHZlciA9IFNvbHZlcjtcblNvbHZlci5vcHMgPSBbXG4gICAgb3BlcmF0aW9ucy5BZGQsIG9wZXJhdGlvbnMuU3VidHJhY3QsIG9wZXJhdGlvbnMuTXVsdGlwbHksXG4gICAgb3BlcmF0aW9ucy5EaXZpZGUsIG9wZXJhdGlvbnMuRXhwb25lbnQsIG9wZXJhdGlvbnMuTG9nXG5dO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///168\n')}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(C.exports,C,C.exports,__webpack_require__),C.exports}__webpack_require__.d=(g,I)=>{for(var C in I)__webpack_require__.o(I,C)&&!__webpack_require__.o(g,C)&&Object.defineProperty(g,C,{enumerable:!0,get:I[C]})},__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(607)})();